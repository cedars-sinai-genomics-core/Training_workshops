---
title: "Bulk RNA Seq"
author: "Alex Rajewski"
date: "4/1/2022"
output: html_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This page is here to help you work through the standard results that the Cedars-Sinai Genomics Core delivers for a bulk RNA seq analysis.
  
# Goals

In this tutorial we will spend some time to give background on the analyses that have been conducted, but the majority of the time will be devoted to showing some ways to plot this data as a number of high-quality, standard figures. By the end of this tutorial you will:

  1.    Understand the basic deliverables from our standard bulk RNA-seq analysis pipeline
  2.    Create a bar graph of gene expression
  3.    Create a volcano plot of log2 fold change and significance for DEGs
  4.    Create a plot of GO term enrichment
  
## Requirements

This tutorial assumes that you have a fairly strong working knowledge of R. Specifically we will be using a number of different functions from the (Tidyverse)[https://www.tidyverse.org] including `dplyr` and `ggplot2`. We'll also use a package called `cowplot` to get some more aesthetically pleasing themes for plots. Although most of these things can be achieved with base R functions, Tidy functions are much easier to read and behave more predictably that a lot of base R functions. Set up your R environment as follows:

```{r libraries}
# Load the tidyverse package
library(tidyverse)
library(cowplot)
```


We assume that you have run results for both Tier 1 (mapping and QC) and Tier 2 (differential analysis) since this provides a rich data set of sample-level gene expression data, significance of differential expression between treatments, and functional enrichment analysis of the DEGs. For this tutorial we provide data from a [published COVID-19 study](https://doi.org/10.1016/j.xcrm.2020.100052) that was analyzed at the Cedars-Sinai Genomics Core.

  -   Counts table: AS-9443--04--17--2020_COUNTS.csv
  -   DEG list: Cov_vs_Mock_DEGs_all.csv
  -   Gene Ontology (GO) Term Enrichment: Cov_vs_Mock_GO.csv
  
# Understanding the Deliverables

At the Genomics Core we have divided our bioinformatic analysis services into several tiers that correspond to increasing complexity and customization. 

## Tier 1 

This level corresponds to the most basic analysis any researcher could need, and, in the case of bulk RNA-seq, involves mapping the reads to a reference genome, quantifying gene expression for each sample, and performing some quality control. In the case where the Genomics Core has done the library prep, this quality control is examine prior to delivery to ensure that both the library prep and sequencing worked well and that we've done everything we can to ensure you have an analyzable experiment. The files are prefixed with the iLab Service ID and uploaded to the GenomicsCloud in the following structure:

```
Primary_data_processing/
├── (Service_ID)_COUNTS.csv
├── (Service_ID)_FPKM.csv
├── (Service_ID).multiqc.html
├── (Service_ID)_QC.pdf
├── (Service_ID)_QC.txt
└── (Service_ID)_TPM.csv
```

The file ending with `.multiqc.html` provides an interactive summary of the run and shows mapping of the reads to various genomic regions, the amount of duplicated reads. The file ending in `_QC.pdf` is a static version of several of these graphs, and the file ending in `_QC.txt` is a numeric summary of many of the metrics.

The other three files, ending with `_COUNTS.csv`, `_FPKM.csv`, and `_TPM.csv` each summarize gene expression for the samples. In each file, the first column contains gene names with both the ENSEMBL gene ID and the gene symbol separated by an underscore (e.g. ENSG00000125398.8_SOX9). The first row contains sample names, although they will have additional information suffixed on. Typically this suffix is something like "_S5_R1_trimmed.genes.results" and it can be ignored for this tutorial. The other cells in the sheets show the expression of a given gene in a given sample. The sheets differ in the ways they summarize expression. `_COUNTS.csv` is the most low-level summary showing the number of reads overlapping a given gene. The quantification software (RSEM) also takes into account the possibility if different isoforms and overlapping genes when creating this summary, although it does not report on the isoform-level. `_FPKM.csv` and `_TPM.csv` each apply different corrections to account for the sequencing depth of the library and the length of genes, each of which can strongly bias the raw count. [Which one you choose](https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/) is up for debate and depends on the analysis. For differential expression analyses counts are preferred by the softwares, which perform their own corrections. For graphing expression, TPM provides the most comparable summary across samples.

## Tier 2

This level allows for differential expression comparisons between treatment groups. In general these comparisons are one or more pairwise comparisons. Other more complex comparisons are possible, but are beyond the scope of this tutorial. This tier may or may not include a pathway analysis of the DEGs depending on the researcher's needs. The results are prefixed with the names of the groups being compared and uploaded to the GenomicsCloud in the following structure:

```
Analysis/
├── Treatment_vs_Control_DEGs_all.csv
├── Treatment_vs_Control_DEGs_padj0.05.csv
├── Treatment_vs_Control_heatmap.pdf
├── Treatment_vs_Control.html
├── Treatment_vs_Control_MAplot.pdf
├── Treatment_vs_Control_PCA_top500.pdf
├── Treatment_vs_Control_Volcano.pdf
└── Pathway
    ├── GO.csv
    ├── GO_p0.05.pdf
    └── GO_padj0.05.pdf
```

Similar to Tier 1, this analysis includes an interactive summary `.html` file, with several of the summary graphs also present as static PDFs include a heatmap, MA plot, PCA, and volcano plot. For differential expression testing, we provide a sheet with all genes tested, regardless of significance (`Treatment_vs_Control_DEGs_all.csv`), but we also provide a filtered list with a more manageable number of DEGs. The filtering criteria adapt to provide the researcher with between 200 and 2000 DEGs if possible. For that reason, you're specific experiment may not have `Treatment_vs_Control_DEGs_padj0.05.csv`, but instead might have `Treatment_vs_Control_DEGs_p0.05.csv` or another filtering criteria appended to the end. Whatever your desired cutoff, you can always go back to the unfiltered list and create the most useful subset though.

The first column of the DEG list is the same combined gene name as in the expression matrices from Tier 1. The second column is the base mean, which provides the **normalized** expression from the control group, while the `log2FoldChange` shows the expression change (in log2 units) for the treatment group. This is followed by a raw p-value, and an adjusted p-value. The adjusted p-value is a more conservating metric and attempts to reduce the number of genes incorrectly called significant because they are false positives. The remaining columns show the **normalized** expression for the samples in the dataset. 

If you have requested a pathway analysis we can provide GO term enrichment, KEGG term enrichment, and/or GSEA. In the above example, we only show a GO term result. `GO.csv` is a list of all of the enriched GO terms from this comparison. By default we only use differentially expressed genes as the input for this analysis, so it is important to settle on an appropriate filtering criteria before this analysis. The first column in this sheet separated the terms into three broad `ONTOLOGY` classes: biological process (BP), molecular function (MF), and cellular component (CC). This is followed by an `ID` number for the term and a `Description` of the term. The `fold enrichment` comes next and describes how enriched this term is among your list of DEGs compared to the rest of the genome. `Count` shows how many genes in your DEG list are annotated with this term, `pvalue` and `p.adjust` show the raw and adjusted p-values, respectively, and finally `geneID` lists all of the gene names in your DEG list that are annotated with this term.

## Tier 3

We also provide more custom bioinformatic services like network analysis, deconvolution using single-cell data, and others. If you are interested, please contact the [Genomics Core](mailto:genomics@cshs.org)

# Bar Graph

The first question most researchers have is "Is my favorite gene differentially expressed?". Apart from showing a table with p-values, there are many ways to represent this visually. The most common method of one or a few genes is a bar graph.

The first challenge we have is that the best expression data to use is in the `_TPM.csv` file, but the p-values that tell us if the change in expression is significant or not are in the `_DEGs_all.csv` file. First we'll read in and prepare the expression data, do the same with the differential expression testing, and finally merge them. 

## Prepare Expression Data

```{r TPM_read, message=FALSE, warning=FALSE}
# Read in the TPM expression values
TPM <- read_csv("Demo/AS-9443--04--17--2020_TPM.csv")

# Check how it looks
head(TPM)
```

We can already see a few issues. When plotting it is important to think about what each row represents. Ideally each row would represent an experimental observation and contain all the information we need to filter out observations or summarize them. Right now each row represents a combination of 6 observations and no distinction is made between treatments (Cov and Mock) or replicates (1, 2, or 3). Luckily that information is contained in the sample names, so we can take advantage of the consistent sample names to reshape the data and create a new data frame (`TPM_Reshape`) where each row represents a single TPM measurement from one gene in one treatment for one replicate. We'll create new columns (Treatment and Replicate) that will allow us to more easily filter the data if we need.

```{r TPM_reshape}
# Do the reshaping
TPM_Reshape <- TPM %>% 
  pivot_longer(cols = c(2:7),names_to = "Sample", values_to = "TPM") %>% 
  mutate(Treatment = gsub("(Cov|Mock)(\\d*)_S\\d*_R\\d*_trimmed.genes.results","\\1",Sample),
         Replicate = gsub("(Cov|Mock)(\\d*)_S\\d*_R\\d*_trimmed.genes.results","\\2",Sample))

#Take a peak at how it looks now
head(TPM_Reshape)
```

Let's look at what we did:

  -   We used a function called `pivot_longer()` to reshape the data frame such that we have one column with all the sample names and another column with all the TPM values instead of one column for each sample. In this new format the gene names are repeated, but it means that each row of the data frame represent a single observation. For this function, we told R which columns to pivot (`cols=`) and what to name the new column with sample names (`names_to=`) and the column of values (`values_to`). There are many ways to select the columns of sample names, but in this case, we just used columns 2 through 7. We called the new columns "Samples" and the values "TPM".
  -   Next we used a function called `mutate()` to create two new columns (`Treatment` and `Replicate`). We recognized that the treatment is the first part of the sample name and is immediately followed by the replicate number, and everything after that is junk but it follows the same pattern. We made a [regular expression](https://raw.githubusercontent.com/rstudio/cheatsheets/main/strings.pdf) statement (`(Cov|Mock)(\\d*)_S\\d*_R\\d*_trimmed.genes.results`) to grab those chunks. This statement says: capture a group of characters that is either Cov or Mock (`(Cov|Mock)`); then capture another group of characters that is a digit (`(\\d*)`); finally capture the suffix at the end that consists of S, some digit, an underscore, R, some digit, another underscore, and the string "trimmed.genes.results" (`_S\\d*_R\\d*_trimmed.genes.results`). The parentheses around the first two groups let us refer back to these grops in the order they were captured using `\\1` or `\\2`. In that way, R can read the entire messy sample name and return on the treatment if we select the first group, or only the replicate if we select the second group. Regular expressions can be tricky and it helps to play around with them, but they are also VERY powerful.
  -   We also used a tidy pipe (`%>%`) to string functions together and do them sequentially, rather than wrapping them in nested parentheses. this makes the chunk of code more readable to humans. Tidy pipes basically take the output of anything on the left side and use it as the default input for whatever function is on the right side. It is conventional to put each function and pipe one its own line for readability. R will assume that any line ending with a pipe will continue on the next line.
  
One last thing to fix is to clean up the gene names. Right now the gene information is in the column `...1` and contains the ENSEMBL ID and the gene symbol separated by an underscore. We can use this consistent naming to split those two apart and create a new column with ust the gene symbol.

```{r TPM_clean}
TPM_Clean <- TPM_Reshape %>% 
  mutate(Gene=gsub("(\\w*\\.+\\d+)_(\\w*)", "\\2",`...1`),
         ...1=NULL,
         Sample=NULL) %>% 
  relocate(Treatment, Replicate, Gene, TPM)
```

Here we did a couple things:

  -   Again we used tidy pipes to apply multiple functions sequentially, `mutate()` followed by `relocate()`
  -   We used `mutate()` with another regular expression to capture the gene name separate from the ENSEMBL ID and put those in a new columns called `Gene`. As a chalenge, how might you modify the above code to return the ENSEMBL IDs instead of gene symbols?
  -   We also used `mutate()` to remove the columns `Sample` and `...1` but setting their values to `NULL`. This is fine since the data from those columns has already been split out into better columns.
  -   Finally, we reordered the columns using `relocate()` so that they have a more intuitive order.
  
The final thing we want to do is to summarize this data. For a bar graph, we'll use the average expression for each treatment, but we'll also need standard error values. We can calculate those here and create a new data frame `TPM_Summary`.

```{r TPM_summarize}
TPM_Summary <- TPM_Clean %>% 
  group_by(Treatment, Gene) %>% 
  mutate(Avg_TPM = mean(TPM),
         SE_TPM = sd(TPM)/sqrt(n())) %>% 
  select(Treatment, Gene, Avg_TPM, SE_TPM) %>% 
  unique()
```

In the above chunk of code we:

  -   Used `group_by()` to create invisible groupings based on each combinations of `Treatment` and `Gene` that will allow us to summarize TPM only within those groups. 
  -   Used `mutate()` to create a new column (`Avg_TPM`) with the mean of the TPM values for all replicates of each gene and treatment, and another column with the standard error (`SE_TPM`) of the same.
  -   Selected only the relevant columns with `select()`
  -   Removed duplicates with `unique()`
  
This will create a data frame where each row represents the average expression of a gene in a given treatment along with it's standard error. Now we are ready to plot it!

## Plot One Gene

For the sake of ease, we'll just pick one gene to plot at first and then we'll generalize this to plot multiple genes with the same format later. 

First we'll create a list of genes we want to plot. Right now, this list will only have one entry, but making a list now will make it easier to scale up later. Since we're usinga COVID dataset, lets pick a gene that we expect might have a strong difference like *ACE2*

```{r GOI_bar_one}
GOIs_1 <- c("ACE2")
```

We can use tidy pipes to pipe our data right into ggplot and filter it for the genes of interest along the way. We'll use the `%in%` operator to only select the genes from our `TPM_Summary` that are present in our list of genes. Let's make a basic, but not very aesthetically pleasing bar graph of *ACE2*.

```{r bar_plot_one_1}
TPM_Summary %>% 
  filter(Gene %in% GOIs_1) %>% 
  ggplot(aes(x=Treatment,
             y=Avg_TPM)) +
  geom_col()
```

This is the minimal plot of gene expression, we have picked the x-axis based on the values in our `Treatment` column and the y-axis from the values in the `Avg_TPM` column. We then used `geom_col()` to represent this data as a column. This works, but it is far from publication quality.

We should add the error bars in order to get a better sense of how different these groups are. We'll do this with the built-in `geom_errorbar()`. We'll need to give it a max and min height for the error bar. Since we reshaped our data to include separate rows for the different treatments, the standard errors were automatically calculated separately like we need. We just need to specify that the top of the error bar is the sum of the average expression and the standard error, while the bottom is the average expression minues the standard error.

```{r bar_plot_one_2}
TPM_Summary %>% 
  filter(Gene %in% GOIs_1) %>% 
  ggplot(aes(x=Treatment,
             y=Avg_TPM)) +
  geom_col() +
  geom_errorbar(aes(ymax = Avg_TPM+SE_TPM,
                    ymin = Avg_TPM-SE_TPM))
```

Now the plot is technically complete in terms of data we need to represent, but we can pretty it up a bit with the following:

  -   A title with the gene name
  -   Rename the y-axis with better formatting
  -   Remove the background grid lines and color
  -   Narrow the error bar a bit
  
```{r bar_plot_one_3}
TPM_Summary %>% 
  filter(Gene %in% GOIs_1) %>% 
  ggplot(aes(x=Treatment,
             y=Avg_TPM)) +
  geom_col() +
  geom_errorbar(aes(ymax = Avg_TPM+SE_TPM,
                    ymin = Avg_TPM-SE_TPM),
                width=0.2) +
  theme_cowplot() +
  labs(x=NULL,
       y="Average Transcripts per Million (TPM)",
       title=GOIs_1) +
  scale_y_continuous(expand = expansion(mult=c(0,0))) +
  theme(plot.title = element_text(face="italic", hjust=0.5))
```

We added a couple things here, so let's talk about each one:

  -   We first applied a theme with `theme_cowplot()`. There are several collections of themes that modify several elements at once. Others to consider are `theme_classic()`, `theme_minimal_grid()`, or `theme_halfopen()`. You could achieve the same effect by manually editing all of the individual theme elements inside of `theme()`, but these provide a good shorthand.
  -   We changes several labels with with `labs()` function. With this function you can manually set the x and y axis labels, the plot title, and others. In this case, we set a manual name for the y-axis, removed the x-axis label, and set the pot title to the gene of interest from our `GOIs_1` list.
  -   We added an argument to `geom_errorbar()` outside of the `aes()` statement. We changed `width=0.2` to narrow the width of the cap on the error bar to 20% of the width of the bar.
  -   We removed the gap between the bottom of the bar and the x-axis by changing the scale of the y-axis with `scale_y_continuous(expand = expansion(mult=c(0,0)))`. This multiplies the end values of the y axis by 0, essentially providing no wiggle rooom between the top and bottom of the data and the axis. Instead of using `expand=` you could manually set y-axis limits with `limits=c(0,13)`, but you would need to change the upper value if we plotted a different gene with higher or lower expression. You may still need to play with the values in the expand statement.
  -   Finally we tweaked the theme a little bit beyond what was set with `theme_cowplot()` with the `theme()` function. This gives us very fine access to many, many elements of the plot. Here we modified the plot title to be a text element that is in italics (`face="italic"`) and horizontally justified to the center (`hjust=0.5`).
  
Finally, we will want to save this plot to a file. R provides several ways to do this, but for a single plot, the easiest is with `ggsave()`. This will save the last plot that was created to a file. It supports several file formats including .pdf, .png, .jpeg, etc. For simple line drawings like this PDF is prefered since the file sizes are very small and you can zoom infinitely without loss of resolution. The function will automatically determine the format based on the file name you provide. You can also specify the dimensions of the final plot with `height=` and `width=`.

```{r bar_save_one}
TPM_Summary %>% 
  filter(Gene %in% GOIs_1) %>% 
  ggplot(aes(x=Treatment,
             y=Avg_TPM)) +
  geom_col() +
  geom_errorbar(aes(ymax = Avg_TPM+SE_TPM,
                    ymin = Avg_TPM-SE_TPM),
                width=0.2) +
  theme_cowplot() +
  labs(x=NULL,
       y="Average Transcripts per Million (TPM)",
       title=GOIs_1) +
  scale_y_continuous(expand = expansion(mult=c(0,0))) +
  theme(plot.title = element_text(face="italic", hjust=0.5))

ggsave("Demo/Bar_1.pdf",
       height=4,
       width=2)
```

## Plot Several Genes

Now that we have a desired plot format, we can pretty easily scale up to making several identical plots. Let's create a new list that has more than one gene, then we cna get to plotting.

```{r GOI_bar_many}
GOIs_Many <- c("ACE2", "SOX9", "PTPRC", "WNT4")
```

To create the same plot many times, we'll use a tidyverse function called `map()`. This takes a list (technically a vector in R terms) of values and repeatedly applies the same function to on each item. `GOIs_Many` is our vector and the plot commands we just developed for one gene are our function that we'll repeatedly apply. When we pass the plotting function to `map()` we'll tell it to assign each gene name to a new variable called `gene_name`. Then, in our plotting commands, we'll substitute any place where we had included our single gene (`GOIs_1`) for this new variable (`gene_name`).

```{r bar_plot_many, message=FALSE, warning=FALSE}
map(GOIs_Many,
    function(gene_name){
      TPM_Summary %>% 
        filter(Gene %in% gene_name) %>% # note the substitution here
        ggplot(aes(x=Treatment,
                   y=Avg_TPM)) +
        geom_col() +
        geom_errorbar(aes(ymax = Avg_TPM+SE_TPM,
                          ymin = Avg_TPM-SE_TPM),
                      width=0.2) +
        theme_cowplot() +
        labs(x=NULL,
             y="Average Transcripts per Million (TPM)",
             title=gene_name) + # and here
        scale_y_continuous(expand = expansion(mult=c(0,0))) +
        theme(plot.title = element_text(face="italic", hjust=0.5))
    })
```

To save these plots, we can't use `ggsave()` since it only saves single-page files. Instead we can use a pair of functions that allow us to open a file, put some plots in it and then close the file. These functions are `pdf()` which opens or creates a new PDF file, and `dev.off()` which finalizes and closes the file. We can just place `pdf()` before and `dev.off()` after the map command we just wrote in order to get a multipage PDF with all of our plots.

```{r bar_save_many, message=FALSE, warning=FALSE}
pdf("Demo/Bar_Many.pdf",
       height=4,
       width=2)
map(GOIs_Many,
    function(gene_name){
      TPM_Summary %>% 
        filter(Gene %in% gene_name) %>% # note the substitution here
        ggplot(aes(x=Treatment,
                   y=Avg_TPM)) +
        geom_col() +
        geom_errorbar(aes(ymax = Avg_TPM+SE_TPM,
                          ymin = Avg_TPM-SE_TPM),
                      width=0.2) +
        theme_cowplot() +
        labs(x=NULL,
             y="Average Transcripts per Million (TPM)",
             title=gene_name) + # and here
        scale_y_continuous(expand = expansion(mult=c(0,0))) +
        theme(plot.title = element_text(face="italic", hjust=0.5))
    })
dev.off()
```

# Volcano Plot

To get a higher-level summary of your experiment, it can be useful to create a volcano plot, which shows each gene as a point and plots the log2 fold change on the x-axis and the -log10 p-value on the y-axis. In this way, you can easy see how many genes are significantly up or down regulated.

All of the data that we will need to create this plot are provided in the Tier 2 results and luckily are already in a format that is already very amenable to plotting.

## Prepare Differential Testing Data

We'll read the data in first.

```{r DEG_read, message=FALSE, warning=FALSE}
# Read in data
DEG <- read_csv("Demo/Cov_vs_Mock_DEGs_all.csv")

# Check how it looks
head(DEG)
```

Here the first column has the same format as with the expression data, where the gene name is provided as the ENSEMBL ID and the gene symbol separated by an underscore. If we ever want to filter the gene list or add labels to points, it will be useful to have only the gene symbol. It isn't strictly necessary for this tutorial to split the column, but we'll do it anyways in case you want to apply an advance plotting on your own. We'll usethe same `mutate()` command as before, but here we'll use a new argument `.before=1` to place the new column at the left of the data frame.

```{r DEG_clean}
DEG_Clean <- DEG %>% 
  mutate(Gene = gsub("(\\w*\\.+\\d+)_(\\w*)", "\\2",Row.names),
         .before=1)

# Check how it looks
head(DEG_Clean)
```

The main data transformation is to convert the p-value to -log10 scale. We could do that during the plotting, but it is computationally better to do it only once before ploting. To avoid overplotting, we will also filter the data to include only significant DEGs. This is a matter or aesthetic preference and you can simply leave out the filtering line to plot all of the genes regardless of significance.

```{r DEG_filter}
# Filter and transform
DEG_Filtered <- DEG_Clean %>% 
  filter(padj<0.05) %>% 
  mutate(neg_log10_padj = -log10(padj))

# Check how it looks
head(DEG_Filtered)
```

## Plot

Once you know the axes, the volcano plot is very straight forward to assemble. 

```{r volc_plot}
DEG_Filtered %>% 
  ggplot(aes(x=log2FoldChange,
             y=neg_log10_padj)) +
  geom_point()
```

That's it for the technically complete volcano plot. Aesthetically, we will probably want to modify several things:

  -   We can remove the background color and gridlines.
  -   We can make the axis labels more readable.
  -   Since there are many points, we can change the transparency of each point so that darker regions will imply many overlapping points.
  -   We have two genes with very high fold changes. Those may or may not be interesting genes, but for illustration we will adjust the x-axis limits to show howto create a more symmetrical plot.

We will also save the plot to a file.
  
```{r volc_save, message=FALSE, warning=FALSE}
DEG_Filtered %>% 
  ggplot(aes(x=log2FoldChange,
             y=neg_log10_padj)) +
  geom_point(alpha=0.2) +
  theme_cowplot() +
  labs(x=expression(log[2]~Fold~Change),
       y=expression("-"*log[10]~Adj.~"p-value")) +
  scale_x_continuous(limits = c(-10,10))
ggsave("Demo/Volcano.pdf",
       heigh=5,
       width=6)
```

Let's review the specific changes that we made:

  -   We used `theme_cowplot()` to quickly modify the background gridlines, background color, and font sizes.
  -   We used `labs()` to manually rename the x- and y-axis labels. In order to get subscripts for the logarithms, we wrapped the label with the `expression()` function that allows us to write more mathematical statements. Syntactically, we can make subscripts by surrounding a number with square brackets, we add spaces by using the tilde (`~`) and we can place two strings adjacent with no space using an asterisk (`*`).
  -   We reset the limits of the x-axis to ±10 with `scale_x_continuous(limits = c(-10,10))`.
  -   We changed the transparency of the points to all by 20% transparent by adding the `alpha=0.2` argument to the `geom_point()` function.


# GO Enrichment

The default GO enrichment plots that we provide show many, many GO terms that are significantly enriched so that researchers can get an overview of all the enriched terms. This can often be overwhelming and ultimately this number of terms is not amenable to plotting for publication since the lists often include a lot of terms that are not specific to the experiment at hand or are redundant. Here we'll show you how to create a GO enrichment bar plot with only a subset of the terms of interest.

The first thing you will need is to create a vector that contains the terms you want to include. The best way to do this is to look through either the `GO.csv` file or one of the PDFs and select a few IDs of terms you'd like. We'll just make a list of a few terms selected at random from the `GO.csv` file. I've ignored significance here so we are making a nonsensical graph for learning purposes.

```{r GO_select}
GO_Terms <- c("GO:0010454", "GO:0048245", "GO:0002730", "GO:0000778", "GO:0050786", "GO:0001741", "GO:0051119")
```

## Prepare GO List

The main thing we'll need to do to this list after we read it in is to filter it, which should be very straight forward compared now that we've completed the filtering and cleaning of the expression and DEG lists.

```{r GO_read, message=FALSE, warning=FALSE}
# Read in
GO <- read_csv("Demo/GO.csv")

# Check how it looks
head(GO)
```


Now we'll filter the list to only include the rows where the ID column matches a value in the list we have just made (`GO_Terms`)


```{r GO_filter}
GO_Filtered <- GO %>% 
  filter(ID %in% GO_Terms)

# check how it looks
GO_Filtered
```

The order that we arrange the terms in isa matter of preference. Often we want the terms with the highest fold enrichment first, but we might want those with the lowest adjusted p-value first instead. We'll arrange the terms by fold enrichment score here, but you could modify the plot by substituting the `fold_enrichment_score` for `p.adjust` instead. When we plot, ggplot can be very arbitrary in how it orders categorical variables like our `Description` column. To force an order, we can convert the column from simple character text into a factor. In R, factors have levels with an implied order to them, which can be directly specified to sort things in a plot. We'll use `mutate()` to convert the `Description` column into a factor with it's levels listed in order of descending fold enrichment.

```{r GO_reorder}
GO_Sort <- GO_Filtered %>% 
  mutate(Description = factor(Description,
                              levels = GO_Filtered$Description[order(GO_Filtered$Fold_Enrichment_Score)])) 
  
```

Note that we didnt create a new column; we overwrote the old one by using the same name for the new and old columns.

We'll create two different arrangements of the plot. The first is a simpler bar plot to show the fold enrichment, and then we will plot it as points and play with the color and size of the dots to layer on other dimensions of data.

## GO Bar Plot

We'll use the text descriptions of terms as categorical y-axis values and plot the fold enrichment scores as the continuous x-value. We'll also save time here by applying the theme elements from previous plots right away.

```{r GO_plot_bar}
GO_Sort %>% 
  ggplot(aes(y=Description,
             x=Fold_Enrichment_Score)) +
  geom_col() +
  theme_cowplot() +
  labs(x="Fold Enrichment Score",
       y=NULL,
       title="Selected GO Terms")
ggsave("Demo/GO_Bar.pdf",
       height=4,
       width=7)
```

## Alternative GO Plot

The above plot is great, but we have lost the information about adjusted p-values and number of genes in each term. You could mention those in the tet of your manuscript, but we can also use another plot to show them all at once. Sometimes you may not need to include all of this information or it may distract from the conclusion you are trying to convey, so try both and pick your favorite.

```{r GO_plot_point1}
GO_Sort %>% 
  ggplot(aes(x=Fold_Enrichment_Score,
             y=Description,
             size=Count,
             color=p.adjust)) +
  geom_point()
```


I've purposely left this initial graph in a pretty rough state so that we can talk about ways to modify size and color aesthetics. Right now we have a lot more information conveyed, but the color scale implicitly draws your eye to the worst p-values, and we have also left out the ontology of the GO terms, which we can layer on with faceting.

Let's tackle the theming first and then move on to faceting.

```{r GO_plot_point2}
GO_Sort %>% 
  ggplot(aes(x=Fold_Enrichment_Score,
             y=Description,
             size=Count,
             color=p.adjust)) +
  geom_point() +
  theme_cowplot() +
  labs(y=NULL,
       x="Fold Enrichment Score",
       title="Selected GO Terms") +
  scale_color_gradient(high="black",
                       low="red",
                       name="Adj. p-value") +
  guides(size = guide_legend(title = "Gene Count"),
         color = guide_legend(reverse=F))
```

Here we have used `labs()` and `theme_cowplot()` as before, but we've newly added `scale_color_gradient()` and `guides()`. It's worth talking about each of these for a little bit.

There are many variations of `scale_X_Y()` where X stands for whatever aesthetic you want to modify (color, fill, size, alpha, x-axis, y-axis) and Y stands for how the scale is structured (continuous, discrete, gradient, etc). We've used `scale_y_continuous()` before to modify elements of a continuous y-axis scale, and we're doing the same thing now to modify a color gradient scale. Specifically we are now specifying the colors for the high and low values. We can do this with a handful of natural language colors ("black", "red"), but we could also use hex values for more precise colors ("#FFFFFF" or "#FF0000'). We also change the title of the color legend from the default 'p.adjust' to "Adj. p-value" with the `name=` argument. There are many other options inside of the scale functions.

Another related function is `guides()` which doesnt modify the scale directly, but instead modifies how that scales is represented in the legend. In our case we are using `guides()` to modify elements of both the legend for size and the legend for color. We specify that we want the legend for size to be the type `guide_legend()` which matches the style of the legend to the geom we used for plotting, points in this case. This doesnt acutally change anything from the default, but we use the argument within to change the title of the size legend from "Count" to "Gene Count". We could have accomplished the same thing with `scale_size_continuous(name="Gene Count")` though. We also use guides to modify aspects of the color scale that we can't access through `scale_color_gradient()`. Namely, we don't want a color bar, but instead want points that match the geom we've used. This has the implicit side effect of reversing the scale so that smaller values are at the top, which is better for out p-value scale.

## Faceting

Up until now, the one thing we've left out of the GO plots is the distinction between the three ontology classes (biological process, molecular function, and cellular component). Many researchers only want biological process, but soem really care other the other classes, and it can be useful to separate them on a graph.

We can do this with faceting, which breaks up a single graph into small multiples based on the values in one or more columns. In this case, we'll create one smaller graph for each of the three ontology classes using `facet_grid()`. to save space, we'll also save this as our final GO term plot

```{r GO_save_point}
GO_Sort %>% 
  ggplot(aes(x=Fold_Enrichment_Score,
             y=Description,
             size=Count,
             color=p.adjust)) +
  geom_point() +
  theme_cowplot() +
  labs(y=NULL,
       x="Fold Enrichment Score",
       title="Selected GO Terms") +
  scale_color_gradient(high="black",
                       low="red",
                       name="Adj. p-value") +
  guides(size = guide_legend(title = "Gene Count"),
         color = guide_legend(reverse=F)) +
  facet_grid(rows = "ONTOLOGY",
             scales = "free",
             space = "free")

ggsave("Demo/GO_Point.pdf",
       height = 5,
       width=9)
```


Within the `facet_wrap()` function, you specify the columns of the data from that will be used to create rows of facets with `rows=` and/or columns of facets with `columns=`. Here we use the data column `ONTOLOGY`, whose three values (BP, CC, MF) will be used to create three rows of facets. By default the facets will have the exact same x- and y-axes and will each take up the same amount of space. Since our y-axis contains terms that each belong to only one ontology, this will create a lot of blank spaces. To avoid this, we can set `scales="free"` and `size="free"` in order to allow both the axis values and the plot sizes to differ among the facets.
